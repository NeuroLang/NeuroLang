# List of example programs to display on the Neurolang web app.

# Top level keys should be keys of neurolang.utils.server.engines.NeurolangEngineConfiguration instances
# passed to the web app (see neurolang.utils.server.app:main).

# For each engine instance, a list of program examples can be specified, with fields
# - id : unique string id for the program
# - title : the string title describing the program
# - shortTitle : shorter string title used to link to the program in the menu
# - query : the neurolang program
# - description : markdown text describing the program
neurosynth:
  - id: "neuro1"
    title: "Coordinate-based meta-analysis (CBMA) on the Neurosynth database"
    shortTitle: "CBMA Single Term"
    query: |
      TermInStudy(term, study) :: (1 / (1 + exp(-300 * (tfidf - 0.001)))) :- TermInStudyTFIDF(term, tfidf, study)
      TermAssociation(term) :- SelectedStudy(study) & TermInStudy(term, study)
      Activation(x, y, z) :- SelectedStudy(s) & PeakReported(x, y, z, s)
      ActivationGivenTerm(x, y, z, PROB) :- Activation(x, y, z) // TermAssociation("emotion")
      ActivationGivenTermImage(agg_create_region_overlay(x, y, z, p)) :- ActivationGivenTerm(x, y, z, p)
    description: |
      In this example, we use the Neurosynth CBMA database (Yarkoni et al., 2011), consisting of 14,371 studies.
      We load the data from the Neurosynth database into tables in the Neurolang engine :
        * **PeakReported** is a relation, or tuple, that includes the peak coordinates (i, j, k) reported in each study.
        * **Study** is a relation, or tuple, with one variable corresponding to the *id* of each study.
        * **SelectedStudy** annotates each study with a probability equal to 1/N of it being chosen out of the whole dataset of size N.

      We write a probabilistic program to query the probability of a peak coordinate being reported by a study given thats
      this study mentions a specific term (i.e . **emotion**).
  - id: "neuro2"
    title: "Coordinate-based meta-analysis (CBMA) on the Neurosynth database"
    shortTitle: "CBMA Multiple Terms"
    query: |
      TermInStudy(term, study) :: (1 / (1 + exp(-300 * (tfidf - 0.001)))) :- TermInStudyTFIDF(term, tfidf, study)
      TermAssociation(term) :- SelectedStudy(study) & TermInStudy(term, study)
      TermsToSelect("emotion")
      TermsToSelect("fear")
      Activation(x, y, z) :- SelectedStudy(s) & PeakReported(x, y, z, s)
      ActivationGivenTerm(x, y, z, t, PROB) :- Activation(x, y, z) // (TermAssociation(t) & TermsToSelect(t))
      ActivationGivenTermImage(t, agg_create_region_overlay(x, y, z, p)) :- ActivationGivenTerm(x, y, z, t, p)
    description: |
      This example is similar to the [CBMA Single Term](/neurosynth/neuro1) example but it showcases how to query multiple term associations.
  - id: "neuro3"
    title: "Coordinate-based meta-analysis (CBMA) with spatial prior smoothing"
    shortTitle: "CBMA Spatial Prior"
    query: |
      VoxelReported (x, y, z, study) :- PeakReported(x2, y2, z2, study) & Voxel(x, y, z) & (d == EUCLIDEAN(x, y, z, x2, y2, z2)) & (d < 4)
      TermInStudy(term, study) :: (1 / (1 + exp(-300 * (tfidf - 0.001)))) :- TermInStudyTFIDF(term, tfidf, study)
      TermAssociation(term) :- SelectedStudy(study) & TermInStudy(term, study)
      Activation(x, y, z) :- SelectedStudy(s) & VoxelReported(x, y, z, s)
      ActivationGivenTerm(x, y, z, PROB) :- Activation(x, y, z) // TermAssociation("emotion")
      ActivationGivenTermImage(agg_create_region_overlay(x, y, z, p)) :- ActivationGivenTerm(x, y, z, p)
    description: |
      This example illustrates how a spatial prior can be defined based on the distance between voxels
      and foci in a coordinate-based meta-analysis database .

      Here, each voxel's probability of being reported by a study is calculated based on whether that particular study
      reports a focus (peak activation) near the voxel. The probability is defined based on how far from the focus that
      voxel happens to be .

destrieux:
  - id: "destrieux1"
    title: "Union of Destrieux atlas regions"
    shortTitle: "Union of atlas regions"
    query: "union(region_union(r)) :- destrieux(..., r)"
  - id: "destrieux2"
    title: "Sulcal Identification Query Example in Neurolang"
    shortTitle: "Sulcal identification"
    query: |
      LeftSulcus(name_, region) :- destrieux(name_, region) & startswith("L S", name_)
      LeftPrimarySulcusName("L S central")
      LeftPrimarySulcusName("L Lat Fis post")
      LeftPrimarySulcusName("L S pericallosal")
      LeftPrimarySulcusName("L S parieto occipital")
      LeftPrimarySulcusName("L S calcarine")
      LeftPrimarySulcusName("L Lat Fis ant Vertical")
      LeftPrimarySulcusName("L Lat Fis ant Horizont")
      LeftPrimarySulcus(name_, region) :- destrieux(name_, region) & LeftPrimarySulcusName(name_)
      LeftFrontalLobeSulcus(region) :- LeftSulcus(..., region) & anatomical_anterior_of(region, lscregion) & destrieux("L S central", lscregion) & anatomical_superior_of(region, llfavregion) & destrieux("L Lat Fis ant Vertical", llfavregion)
      LPrecentralSulcus(r) :- LeftFrontalLobeSulcus(r) & principal_direction(r, "SI") & ~exists(r2; LeftFrontalLobeSulcus(r2) & LeftFrontalLobeSulcus(r) & (r2 != r) & anatomical_posterior_of(r2, r))
    description: |
      In this example, we first caracterise some of the sulci in the Destrieux et al. Atlas. We characterise:
        * the left hemisphere primary sulci, by name
        * the left frontal lobe sulcus as those
          - anterior to Destrieux's left central sulcus
          - superior to Destrieux's left anterio-vertical section of the lateral fissure .

      We then identify the left precentral sulcus (PC) as:
        * belonging to the left frontal lobe
        * its principal direction is along the superior-inferior axis.
        * no other sulcus satisfying the same conditions is anterior to the PC.

fpcn:
  - id: "fpcn_coactivation"
    title: "fpcn_coactivation TITLE"
    shortTitle: "fpcn_coactivation SHORTTITLE"
    query: |
      RegionReported(r, s) :- PeakReportedNQ(i, j, k, s) & RegionVoxel(r, i, j, k)
      RegionVolume(r, count(i, j, k)) :- RegionVoxel(r, i, j, k)
      NetworkVolume(n, sum(v)) :- RegionVolume(r, v) & NetworkRegion(n, r)
      NetworkReportedVolume(network, study, sum(volume)) :- NetworkRegion(network, region) & RegionReported(region, study) & RegionVolume(region, volume)
      NetworkReported(network, study) :: (prob) :- NetworkVolume(network, nv) & NetworkReportedVolume(network, study, nrv) & (prob == nrv / nv)
      ProbActivationGivenNetworkActivation(r, n, PROB(r, n)) :- (RegionReported(r, s) & SelectedStudyNQ(s)) // (NetworkReported(n, s) & SelectedStudyNQ(s))
      ProbActivationGivenNoNetworkActivation(r, n, PROB(r, n)) :- (RegionReported(r, s) & SelectedStudyNQ(s)) // (~NetworkReported(n, s) & Network(n) & SelectedStudyNQ(s))
      ProbActivation(r, PROB(r)) :- RegionReported(r, s) & SelectedStudyNQ(s)
      CountStudies(count(s)) :- StudyNQ(s)
      CountStudiesRegionReported(r, count(s)) :- RegionReported(r, s)
      ProbNetworkReported(n, PROB(n)) :- NetworkReported(n, s) & SelectedStudyNQ(s)
      CountStudiesNetworkReported(n, count) :- ProbNetworkReported(n, prob) & CountStudies(N) & (count == prob * N)
      ProbRegionAndNetworkReported(r, n, PROB(r, n)) :- RegionReported(r, s) & NetworkReported(n, s) & SelectedStudyNQ(s)
      CountStudiesRegionAndNetworkReported(r, n, count) :- ProbRegionAndNetworkReported(r, n, prob) & CountStudies(N) & (count == prob * N)
      Counts(region, network, N, n, m, k) :- CountStudies(N) & CountStudiesRegionReported(region, m) & CountStudiesNetworkReported(network, n) & CountStudiesRegionAndNetworkReported(region, network, k)
      Query(region, network, p, p0, p1, llr, N, n, m, k) :- ProbActivation(region, p) & ProbActivationGivenNoNetworkActivation(region, network, p0) & ProbActivationGivenNetworkActivation(region, network, p1) & Counts(region, network, N, n, m, k) & (llr == ((k * log(p1) + (n - k) * log(1 - p1) + (m - k) * log(p0) + (N - n - m + k) * log(1 - p0)) - (k * log(p) + (n - k) * log(1 - p) + (m - k) * log(p) + (N - n - m + k) * log(1 - p))))
  - id: "fpcn_reverse"
    title: "fpcn_reverse TITLE"
    shortTitle: "fpcn_reverse SHORTTITLE"
    query: |
      RegionReported(r, s) :- PeakReported(i, j, k, s) & RegionVoxel(r, i, j, k)
      RegionVolume(r, count(i, j, k)) :- RegionVoxel(r, i, j, k)
      NetworkVolume(n, sum(v)) :- RegionVolume(r, v) & NetworkRegion(n, r)
      NetworkReportedVolume(network, study, sum(volume)) :- NetworkRegion(network, region) & RegionReported(region, study) & RegionVolume(region, volume)
      NetworkReported(network, study) :: (prob) :- NetworkVolume(network, nv) & NetworkReportedVolume(network, study, nrv) & (prob == nrv / nv)
      ProbTopicAssociationGivenNetworkActivation(t, n, PROB(t, n)) :- (TopicAssociation(t, s) & SelectedStudy(s)) // (NetworkReported(n, s) & SelectedStudy(s))
      ProbTopicAssociationGivenNoNetworkActivation(t, n, PROB(t, n)) :- (TopicAssociation(t, s) & SelectedStudy(s)) // (~NetworkReported(n, s) & Network(n) & SelectedStudy(s))
      ProbTopicAssociation(t, PROB(t)) :- TopicAssociation(t, s) & SelectedStudy(s)
      CountStudies(count(s)) :- Study(s)
      CountStudiesTopicAssociation(t, count) :- ProbTopicAssociation(t, prob) & CountStudies(N) & (count == prob * N)
      ProbNetworkReported(n, PROB(n)) :- NetworkReported(n, s) & SelectedStudy(s)
      CountStudiesNetworkReported(n, count) :- ProbNetworkReported(n, prob) & CountStudies(N) & (count == prob * N)
      ProbTopicAssociationAndNetworkReported(t, n, PROB(t, n)) :- TopicAssociation(t, s) & NetworkReported(n, s) & SelectedStudy(s)
      CountStudiesTopicAssociationAndNetworkReported(t, n, count) :- ProbTopicAssociationAndNetworkReported(t, n, prob) & CountStudies(N) & (count == prob * N)
      Counts(topic, network, N, n, m, k) :- CountStudies(N) & CountStudiesTopicAssociation(topic, m) & CountStudiesNetworkReported(network, n)& CountStudiesTopicAssociationAndNetworkReported(topic, network, k)
      Query(topic, network, p_topic, p_network, p0, p1, llr, N, n, m, k,) :- ProbTopicAssociation(topic, p_topic) & ProbNetworkReported(network, p_network) & ProbTopicAssociationGivenNoNetworkActivation(topic, network, p0)& ProbTopicAssociationGivenNetworkActivation(topic, network, p1)& Counts(topic, network, N, n, m, k) & (llr == ((k * log(p1) + (n - k) * log(1 - p1) + (m - k) * log(p0) + (N - n - m + k) * log(1 - p0)) - (k * log(p_topic) + (n - k) * log(1 - p_topic) + (m - k) * log(p_topic) + (N - n - m + k) * log(1 - p_topic))))

vwfa:
  - id: "vwfa_term"
    title: "vwfa_term TITLE"
    shortTitle: "vwfa_term SHORTTITLE"
    query: |
      RegionReported(r, s) :- PeakReportedNQ(x1, y1, z1, s) & RegionSeedVoxel(r, x2, y2, z2) & (d == EUCLIDEAN(x1, y1, z1, x2, y2, z2)) & (d < 10.0)
      NetworkReported(n, s) :- RegionReported(r, s) & RegionInNetwork(r, n)
      StudyMatchingNetworkQuery(s, n) :- RegionReported("VWFA", s) & NetworkReported(n, s) & ~exists(n2; (n2 != n) & NetworkReported(n2, s) & Network(n2))
      StudyNotMatchingSegregationQuery(s, n) :- ~StudyMatchingNetworkQuery(s, n) & StudyNQ(s) & Network(n)
      PositiveReverseInferenceSegregationQuery(t, n, PROB(t, n)) :- (TermAssociation(t, s) & SelectedStudyNQ(s)) // (StudyMatchingNetworkQuery(s, n) & SelectedStudyNQ(s))
      NegativeReverseInferenceSegregationQuery(t, n, PROB(t, n)) :- (TermAssociation(t, s) & SelectedStudyNQ(s)) // (StudyNotMatchingSegregationQuery(s, n) & SelectedStudyNQ(s))
      MarginalTermAssociation(t, PROB(t)) :- SelectedStudyNQ(s) & TermAssociation(t, s)
      CountStudies(count(s)) :- StudyNQ(s)
      CountStudiesWithTerm(t, c) :- MarginalTermAssociation(t, prob) & (c == prob * N) & CountStudies(N)
      CountStudiesMatchingQuery(n, count(s)) :- StudyMatchingNetworkQuery(s, n)
      JointProb(t, n, PROB(t, n)) :- TermAssociation(t, s) & StudyMatchingNetworkQuery(s, n) & SelectedStudyNQ(s)
      CountStudiesMatchingQueryWithTerm(t, n, c) :- JointProb(t, n, p)& CountStudies(N)& (c == N * p)
      LikelihoodRatio(term, network, p1, p0, llr, m, n, k) :- PositiveReverseInferenceSegregationQuery(term, network, p1) & NegativeReverseInferenceSegregationQuery(term, network, p0) & MarginalTermAssociation(term, p) & CountStudies(N) & CountStudiesWithTerm(term, m) & CountStudiesMatchingQuery(network, n) & CountStudiesMatchingQueryWithTerm(term, network, k) & (llr== ((k * log(p1)+ (n - k) * log(1 - p1)+ (m - k) * log(p0)+ (N - n - m + k) * log(1 - p0)) - (k * log(p)+ (n - k) * log(1 - p)+ (m - k) * log(p)+ (N - n - m + k) * log(1 - p))))
  - id: "vwfa_topic"
    title: "vwfa_topic TITLE"
    shortTitle: "vwfa_topic SHORTTITLE"
    query: |
      RegionReported(r, s) :- PeakReported(x1, y1, z1, s) & RegionSeedVoxel(r, x2, y2, z2) & (d == EUCLIDEAN(x1, y1, z1, x2, y2, z2)) & (d < 10.0)
      NetworkReported(n, s) :- RegionReported(r, s) & RegionInNetwork(r, n)
      StudyMatchingNetworkQuery(s, n) :- RegionReported("VWFA", s) & NetworkReported(n, s) & ~exists(n2; (n2 != n) & NetworkReported(n2, s) & Network(n2))
      StudyNotMatchingSegregationQuery(s, n) :- ~StudyMatchingNetworkQuery(s, n) & Study(s) & Network(n)
      PositiveReverseInferenceSegregationQuery(t, n, PROB(t, n)) :- (TopicAssociation(t, s) & SelectedStudy(s)) // (StudyMatchingNetworkQuery(s, n) & SelectedStudy(s))
      NegativeReverseInferenceSegregationQuery(t, n, PROB(t, n)) :- (TopicAssociation(t, s) & SelectedStudy(s)) // (StudyNotMatchingSegregationQuery(s, n) & SelectedStudy(s))
      MarginalTopicAssociation(t, PROB(t)) :- SelectedStudy(s) & TopicAssociation(t, s)
      CountStudies(count(s)) :- Study(s)
      CountStudiesWithTopic(t, c) :- MarginalTopicAssociation(t, prob) & (c == prob * N) & CountStudies(N)
      CountStudiesMatchingQuery(n, count(s)) :- StudyMatchingNetworkQuery(s, n)
      JointProb(t, n, PROB(t, n)) :- TopicAssociation(t, s) & StudyMatchingNetworkQuery(s, n) & SelectedStudy(s)
      CountStudiesMatchingQueryWithTopic(t, n, c) :- JointProb(t, n, p) & CountStudies(N) & (c == N * p)
      LikelihoodRatio(topic, network, p1, p0, llr, m, n, k) :- PositiveReverseInferenceSegregationQuery(topic, network, p1) & NegativeReverseInferenceSegregationQuery(topic, network, p0) & MarginalTopicAssociation(topic, p) & CountStudies(N) & CountStudiesWithTopic(topic, m) & CountStudiesMatchingQuery(network, n) & CountStudiesMatchingQueryWithTopic(topic, network, k) & (llr == ((k * log(p1) + (n - k) * log(1 - p1) + (m - k) * log(p0) + (N - n - m + k) * log(1 - p0)) - (k * log(p) + (n - k) * log(1 - p) + (m - k) * log(p) + (N - n - m + k) * log(1 - p))))

network:
  - id: "network_reverse"
    title: "network_reverse TITLE"
    shortTitle: "network_reverse SHORTTITLE"
    query: |
      RegionReported(r, s) :- PeakReported(x, y, z, s) & RegionVoxel(r, x, y, z)
      RegionVolume(r, count(x, y, z)) :- RegionVoxel(r, x, y, z)
      NetworkVolume(n, sum(v)) :- RegionVolume(r, v) & NetworkRegion(n, r)
      NetworkReportedVolume(n, s, sum(v)) :- NetworkRegion(n, region) & RegionReported(region, s) & RegionVolume(region, v)
      NetworkReported(n, s) :: (nrv / nv) :- NetworkVolume(n, nv) & NetworkReportedVolume(n, s, nrv)
      StudyMatchingNetworkSegregationQuery(s, n) :- NetworkReported(n, s) & ~exists(n2; Network(n2) & (n2 != n) & NetworkReported(n2, s))
      Query(topic, n, PROB(topic, n)) :- TopicAssociation(topic, s) // (StudyMatchingNetworkSegregationQuery(s, n) & SelectedStudy(s))

